<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Tree ç®—æ³•åŠ¨æ€æ¼”ç¤º</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
            color: #333;
        }
        
        .container {
            max-width: 95vw;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            min-height: 90vh;
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            color: #4a5568;
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            color: #4a5568;
        }
        
        .btn-success {
            background: linear-gradient(45deg, #d299c2, #fef9d7);
            color: #4a5568;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        
        .visualization {
            display: flex;
            gap: 40px;
            margin-top: 30px;
            height: calc(100vh - 300px);
            min-height: 600px;
        }
        
        .canvas-container {
            flex: 1;
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        
        canvas {
            border: 3px solid #e2e8f0;
            border-radius: 10px;
            background: #f8fafc;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            width: 100%;
            height: 100%;
        }
        
        .info-panel {
            flex: 1;
            min-width: 350px;
            background: #f8fafc;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .step-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #ff9a9e;
        }
        
        .step-title {
            font-weight: bold;
            color: #4a5568;
            margin-bottom: 8px;
        }
        
        .step-description {
            color: #718096;
            line-height: 1.5;
        }
        
        .tree-structure {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #a8edea;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .tree-structure:last-child {
            margin-bottom: 0;
        }
        
        /* D3 æ ‘å½¢å›¾æ ·å¼ */
        .tree-node {
            cursor: pointer;
        }
        
        .tree-node circle {
            fill: #fff;
            stroke: #4a5568;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }
        
        .tree-node.internal-node circle {
            fill: #ff9a9e;
        }
        
        .tree-node.leaf-node circle {
            fill: #a8edea;
        }
        
        .tree-node.building circle {
            fill: #ffd700;
            stroke: #ff6b35;
            stroke-width: 3px;
            animation: pulse 1.5s infinite;
        }

        .tree-node.searching circle {
            fill: #ffd700;
            stroke: #ff6b35;
            stroke-width: 4px;
            animation: searchPulse 1s infinite;
        }

        @keyframes searchPulse {
            0% { transform: scale(1); stroke-width: 4px; }
            50% { transform: scale(1.2); stroke-width: 6px; }
            100% { transform: scale(1); stroke-width: 4px; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .author-info {
            text-align: center;
            padding: 20px;
            color: #718096;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.8);
            margin-top: 20px;
        }

        .author-info a {
            color: #ff9a9e;
            text-decoration: none;
            font-weight: 500;
        }

        .author-info a:hover {
            color: #fecfef;
            text-decoration: underline;
        }

        .speed-control-container {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }

        .speed-control {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-label {
            color: #4a5568;
            font-weight: 500;
            white-space: nowrap;
        }

        .speed-btn {
            margin: 0 5px;
            padding: 5px 10px;
            border: 1px solid #ff9a9e;
            background: white;
            color: #ff9a9e;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .speed-btn:hover {
            background: #ff9a9e !important;
            color: white !important;
            transform: translateY(-1px);
        }

        .speed-slider {
            width: 200px;
            margin: 0 10px;
        }

        .speed-value {
            color: #ff9a9e;
            font-weight: bold;
            margin-left: 10px;
            white-space: nowrap;
        }

        .algorithm-intro {
            background: linear-gradient(135deg, #fef7f7 0%, #fed7e2 100%);
            padding: 40px 20px;
            margin-top: 40px;
        }

        .intro-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .algorithm-intro h2 {
            text-align: center;
            color: #2d3748;
            font-size: 2.2em;
            margin-bottom: 30px;
            font-weight: 700;
        }

        .intro-section {
            background: white;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border-left: 4px solid #ff9a9e;
        }

        .intro-section h3 {
            color: #4a5568;
            font-size: 1.3em;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .intro-section p {
            color: #718096;
            line-height: 1.7;
            margin-bottom: 15px;
        }

        .intro-section ul {
            color: #718096;
            line-height: 1.7;
            padding-left: 20px;
        }

        .intro-section li {
            margin-bottom: 8px;
        }

        .intro-section li strong {
            color: #4a5568;
        }

        .advantages {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .advantage-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 15px;
            background: #fef7f7;
            border-radius: 8px;
            border: 1px solid #fed7e2;
        }

        .advantage-icon {
            font-size: 1.5em;
            flex-shrink: 0;
        }

        .advantage-item strong {
            color: #4a5568;
            display: block;
            margin-bottom: 5px;
        }

        .advantage-item p {
            color: #718096;
            font-size: 0.9em;
            margin: 0;
        }

        .applications {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .app-tag {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
        }

        .comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .comparison-item {
            background: #fef7f7;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #fed7e2;
        }

        .comparison-item h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .comparison-item ul {
            margin: 0;
            padding-left: 20px;
        }

        .complexity {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .complexity-item {
            background: #fef7f7;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #fed7e2;
            color: #4a5568;
            font-weight: 500;
        }

        .speed-control input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            outline: none;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ff9a9e;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .speed-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ff9a9e;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }


        
        .tree-node:hover circle {
            stroke-width: 3px;
            transform: scale(1.1);
        }
        
        .tree-node text {
            font: 10px sans-serif;
            fill: #4a5568;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }
        
        .tree-link {
            fill: none;
            stroke: #718096;
            stroke-width: 1.5px;
            stroke-opacity: 0.6;
        }
        
        .tree-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #d299c2;
        }
        
        .stats-title {
            font-weight: bold;
            color: #4a5568;
            margin-bottom: 8px;
        }
        
        .stats-content {
            color: #718096;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>âš½ Ball Tree ç®—æ³•åŠ¨æ€æ¼”ç¤º</h1>
        
        <div class="controls">
            <button class="btn-primary" onclick="generateRandomPoints()">ç”Ÿæˆéšæœºç‚¹</button>
            <button class="btn-secondary" onclick="buildBallTree()">æ„å»º Ball Tree</button>
            <button class="btn-success" onclick="startSearch()">å¼€å§‹æœç´¢</button>
            <button class="btn-secondary" onclick="toggleSearchPause()" id="pauseBtn" style="display: none;">æš‚åœ</button>
            <button class="btn-primary" onclick="reset()">é‡ç½®</button>
        </div>

        <div class="speed-control-container">
            <div class="speed-control">
                <label for="speedSlider" class="speed-label">æœç´¢é€Ÿåº¦:</label>
                <button onclick="setSpeed(0.5)" class="speed-btn">å¿«é€Ÿ</button>
                <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1.5" 
                       class="speed-slider" onchange="updateSearchSpeed()">
                <button onclick="setSpeed(3)" class="speed-btn">æ…¢é€Ÿ</button>
                <span id="speedValue" class="speed-value">1.5s</span>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #3182ce;"></div>
                <span>æ•°æ®ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e53e3e;"></div>
                <span>æŸ¥è¯¢ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #38a169;"></div>
                <span>æœ€è¿‘é‚»</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(128, 90, 213, 0.3);"></div>
                <span>çƒå½¢åŒºåŸŸ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #805ad5;"></div>
                <span>ä¸­å¿ƒç‚¹</span>
            </div>
        </div>
        
        <div class="visualization">
            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            
            <div class="info-panel">
                <div class="step-info">
                    <div class="step-title">å½“å‰æ­¥éª¤</div>
                    <div class="step-description" id="stepDescription">
                        ç‚¹å‡»"ç”Ÿæˆéšæœºç‚¹"å¼€å§‹æ¼”ç¤º
                    </div>
                </div>
                
                <div class="tree-structure">
                    <div style="font-weight: bold; margin-bottom: 10px; color: #4a5568;">æ„å»ºä¿¡æ¯:</div>
                    <div id="buildInfo" style="margin-bottom: 15px; color: #718096; font-size: 14px;">
                        ç‚¹å‡»"ç”Ÿæˆéšæœºç‚¹"å¼€å§‹
                    </div>
                </div>
                
                <div class="tree-structure" style="flex: 1; display: flex; flex-direction: column;">
                    <div style="font-weight: bold; margin-bottom: 10px; color: #4a5568;">æ ‘ç»“æ„å¯è§†åŒ–:</div>
                    <div id="treeVisualization" style="width: 100%; flex: 1; border: 1px solid #e2e8f0; border-radius: 5px; background: #f8fafc;">
                        <svg id="treeSvg" width="100%" height="100%"></svg>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="algorithm-intro">
        <div class="intro-container">
            <h2>âš½ Ball Tree ç®—æ³•ä»‹ç»</h2>
            
            <div class="intro-section">
                <h3>ğŸ“– ç®—æ³•æ¦‚è¿°</h3>
                <p>Ball Treeæ˜¯ä¸€ç§åŸºäºçƒå½¢åŒºåŸŸçš„ç©ºé—´æ•°æ®ç»“æ„ï¼Œç‰¹åˆ«é€‚ç”¨äºé«˜ç»´ç©ºé—´ä¸­çš„æœ€è¿‘é‚»æœç´¢ã€‚ä¸K-D Treeä¸åŒï¼ŒBall Treeä½¿ç”¨è¶…çƒé¢è€Œéè¶…å¹³é¢æ¥åˆ†å‰²ç©ºé—´ï¼Œåœ¨é«˜ç»´æ•°æ®ä¸Šè¡¨ç°æ›´ä¼˜ã€‚</p>
            </div>

            <div class="intro-section">
                <h3>ğŸ”§ æ ¸å¿ƒæ€æƒ³</h3>
                <ul>
                    <li><strong>çƒå½¢åˆ†å‰²</strong>ï¼šæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªåŒ…å«æ‰€æœ‰å­èŠ‚ç‚¹æ•°æ®ç‚¹çš„æœ€å°çƒå½¢åŒºåŸŸ</li>
                    <li><strong>é€’å½’æ„å»º</strong>ï¼šé€‰æ‹©æœ€ä¼˜åˆ†å‰²ç»´åº¦ï¼Œå°†æ•°æ®ç‚¹åˆ†ä¸ºä¸¤ä¸ªå­çƒ</li>
                    <li><strong>è´¨å¿ƒè®¡ç®—</strong>ï¼šè®¡ç®—æ•°æ®ç‚¹çš„è´¨å¿ƒä½œä¸ºçƒå¿ƒï¼Œæœ€è¿œè·ç¦»ä½œä¸ºåŠå¾„</li>
                    <li><strong>è·ç¦»å‰ªæ</strong>ï¼šåˆ©ç”¨çƒå½¢è¾¹ç•Œè¿›è¡Œé«˜æ•ˆçš„è·ç¦»å‰ªæ</li>
                </ul>
            </div>

            <div class="intro-section">
                <h3>ğŸš€ ç®—æ³•ä¼˜åŠ¿</h3>
                <div class="advantages">
                    <div class="advantage-item">
                        <span class="advantage-icon">ğŸŒ</span>
                        <div>
                            <strong>é«˜ç»´å‹å¥½</strong>
                            <p>åœ¨é«˜ç»´ç©ºé—´ä¸­æ€§èƒ½ä¼˜äºK-D Tree</p>
                        </div>
                    </div>
                    <div class="advantage-item">
                        <span class="advantage-icon">âœ‚ï¸</span>
                        <div>
                            <strong>æœ‰æ•ˆå‰ªæ</strong>
                            <p>çƒå½¢è¾¹ç•Œæä¾›æ›´ç²¾ç¡®çš„å‰ªææ¡ä»¶</p>
                        </div>
                    </div>
                    <div class="advantage-item">
                        <span class="advantage-icon">ğŸ“Š</span>
                        <div>
                            <strong>æ•°æ®è‡ªé€‚åº”</strong>
                            <p>æ ¹æ®æ•°æ®åˆ†å¸ƒè‡ªé€‚åº”è°ƒæ•´çƒå½¢åŒºåŸŸ</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="intro-section">
                <h3>ğŸ’¡ åº”ç”¨åœºæ™¯</h3>
                <div class="applications">
                    <span class="app-tag">ğŸ§  æ·±åº¦å­¦ä¹ </span>
                    <span class="app-tag">ğŸ“ æ–‡æœ¬æ£€ç´¢</span>
                    <span class="app-tag">ğŸµ éŸ³é¢‘è¯†åˆ«</span>
                    <span class="app-tag">ğŸ”¬ ç”Ÿç‰©ä¿¡æ¯å­¦</span>
                    <span class="app-tag">ğŸ’° é‡‘èåˆ†æ</span>
                    <span class="app-tag">ğŸ¯ æ¨èç³»ç»Ÿ</span>
                </div>
            </div>

            <div class="intro-section">
                <h3>âš–ï¸ ä¸K-D Treeå¯¹æ¯”</h3>
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>ğŸŒ³ K-D Tree</h4>
                        <ul>
                            <li>é€‚ç”¨äºä½ç»´æ•°æ®ï¼ˆâ‰¤20ç»´ï¼‰</li>
                            <li>ä½¿ç”¨è¶…å¹³é¢åˆ†å‰²</li>
                            <li>æ„å»ºç®€å•å¿«é€Ÿ</li>
                        </ul>
                    </div>
                    <div class="comparison-item">
                        <h4>âš½ Ball Tree</h4>
                        <ul>
                            <li>é€‚ç”¨äºé«˜ç»´æ•°æ®ï¼ˆ>20ç»´ï¼‰</li>
                            <li>ä½¿ç”¨è¶…çƒé¢åˆ†å‰²</li>
                            <li>å‰ªææ•ˆæœæ›´å¥½</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="intro-section">
                <h3>ğŸ“ˆ å¤æ‚åº¦åˆ†æ</h3>
                <div class="complexity">
                    <div class="complexity-item">
                        <strong>æ„å»ºæ—¶é—´</strong>: O(n log n)
                    </div>
                    <div class="complexity-item">
                        <strong>æœç´¢æ—¶é—´</strong>: O(log n) å¹³å‡
                    </div>
                    <div class="complexity-item">
                        <strong>ç©ºé—´å¤æ‚åº¦</strong>: O(n)
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="author-info">
        by <a href="https://afoo.me" target="_blank">ç¦å¼º</a> & Kiro
    </div>

    <script>
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            distance(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }
        }
        
        class BallNode {
            constructor(center, radius, points = [], left = null, right = null) {
                this.center = center;
                this.radius = radius;
                this.points = points;
                this.left = left;
                this.right = right;
                this.isLeaf = points.length > 0 && !left && !right;
            }
        }
        
        class BallTree {
            constructor(leafSize = 5) {
                this.root = null;
                this.leafSize = leafSize;
                this.buildSteps = [];
                this.nodeCount = 0;
            }
            
            build(points) {
                this.buildSteps = [];
                this.nodeCount = 0;
                this.root = this.buildRecursive(points, 0);
                return this.buildSteps;
            }
            
            buildRecursive(points, depth) {
                if (points.length === 0) return null;
                
                this.nodeCount++;
                
                // Calculate centroid
                const center = this.calculateCentroid(points);
                
                // Calculate radius (maximum distance from center to any point)
                let radius = 0;
                points.forEach(point => {
                    const dist = center.distance(point);
                    if (dist > radius) radius = dist;
                });
                
                this.buildSteps.push({
                    type: 'create_ball',
                    center: center,
                    radius: radius,
                    points: [...points],
                    depth: depth,
                    isLeaf: points.length <= this.leafSize
                });
                
                // If few enough points, make it a leaf
                if (points.length <= this.leafSize) {
                    return new BallNode(center, radius, points);
                }
                
                // Find the dimension with maximum spread
                const split = this.findBestSplit(points);
                
                this.buildSteps.push({
                    type: 'split',
                    center: center,
                    splitDimension: split.dimension,
                    splitValue: split.value,
                    leftPoints: split.leftPoints,
                    rightPoints: split.rightPoints,
                    depth: depth
                });
                
                const node = new BallNode(center, radius);
                node.left = this.buildRecursive(split.leftPoints, depth + 1);
                node.right = this.buildRecursive(split.rightPoints, depth + 1);
                
                return node;
            }
            
            calculateCentroid(points) {
                let sumX = 0, sumY = 0;
                points.forEach(point => {
                    sumX += point.x;
                    sumY += point.y;
                });
                return new Point(sumX / points.length, sumY / points.length);
            }
            
            findBestSplit(points) {
                // Try splitting on both dimensions and choose the one with better balance
                const splits = [
                    this.splitOnDimension(points, 0), // x dimension
                    this.splitOnDimension(points, 1)  // y dimension
                ];
                
                // Choose split with better balance (closer to 50-50)
                return splits.reduce((best, current) => {
                    const bestBalance = Math.abs(best.leftPoints.length - best.rightPoints.length);
                    const currentBalance = Math.abs(current.leftPoints.length - current.rightPoints.length);
                    return currentBalance < bestBalance ? current : best;
                });
            }
            
            splitOnDimension(points, dimension) {
                // Sort points by the chosen dimension
                const sorted = [...points].sort((a, b) => {
                    return dimension === 0 ? a.x - b.x : a.y - b.y;
                });
                
                const medianIndex = Math.floor(sorted.length / 2);
                const splitValue = dimension === 0 ? sorted[medianIndex].x : sorted[medianIndex].y;
                
                const leftPoints = sorted.slice(0, medianIndex);
                const rightPoints = sorted.slice(medianIndex);
                
                return {
                    dimension: dimension,
                    value: splitValue,
                    leftPoints: leftPoints,
                    rightPoints: rightPoints
                };
            }
            
            findNearest(queryPoint) {
                if (!this.root) return null;
                
                let best = null;
                let bestDistance = Infinity;
                const searchSteps = [];
                
                const search = (node, depth) => {
                    if (!node) return;
                    
                    // Calculate distance from query point to ball center
                    const centerDistance = queryPoint.distance(node.center);
                    
                    searchSteps.push({
                        type: 'visit_ball',
                        node: node,
                        centerDistance: centerDistance,
                        canPrune: centerDistance - node.radius > bestDistance
                    });
                    
                    // Pruning: if the distance to the ball center minus the radius
                    // is greater than current best distance, we can skip this ball
                    if (centerDistance - node.radius > bestDistance) {
                        searchSteps.push({
                            type: 'prune',
                            node: node,
                            reason: 'Ball too far away'
                        });
                        return;
                    }
                    
                    if (node.isLeaf) {
                        // Check all points in the leaf
                        node.points.forEach(point => {
                            const distance = queryPoint.distance(point);
                            searchSteps.push({
                                type: 'check_point',
                                point: point,
                                distance: distance,
                                isBest: distance < bestDistance
                            });
                            
                            if (distance < bestDistance) {
                                best = point;
                                bestDistance = distance;
                            }
                        });
                    } else {
                        // Recursively search children
                        // Search the closer child first
                        const leftDistance = node.left ? queryPoint.distance(node.left.center) : Infinity;
                        const rightDistance = node.right ? queryPoint.distance(node.right.center) : Infinity;
                        
                        if (leftDistance < rightDistance) {
                            search(node.left, depth + 1);
                            search(node.right, depth + 1);
                        } else {
                            search(node.right, depth + 1);
                            search(node.left, depth + 1);
                        }
                    }
                };
                
                search(this.root, 0);
                
                return {
                    nearest: best,
                    distance: bestDistance,
                    steps: searchSteps
                };
            }
            
            getDepth() {
                const calculateDepth = (node) => {
                    if (!node) return 0;
                    return 1 + Math.max(calculateDepth(node.left), calculateDepth(node.right));
                };
                return calculateDepth(this.root);
            }
        }
        
        // Visualization
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let points = [];
        let ballTree = new BallTree();
        let buildSteps = [];
        let currentStep = 0;
        let queryPoint = null;
        let searchResult = null;
        let animationId = null;
        
        function generateRandomPoints() {
            points = [];
            // Generate clustered points for better ball tree demonstration
            const clusters = 3;
            const pointsPerCluster = 8;
            
            for (let i = 0; i < clusters; i++) {
                const centerX = Math.random() * (canvas.width - 200) + 100;
                const centerY = Math.random() * (canvas.height - 200) + 100;
                
                for (let j = 0; j < pointsPerCluster; j++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = Math.random() * 60 + 10;
                    
                    points.push(new Point(
                        centerX + Math.cos(angle) * radius,
                        centerY + Math.sin(angle) * radius
                    ));
                }
            }
            
            reset();
            drawPoints();
            updateStepDescription("å·²ç”Ÿæˆ " + points.length + " ä¸ªèšç±»ç‚¹ï¼Œç‚¹å‡»\"æ„å»º Ball Tree\"ç»§ç»­");
            updateBuildInfo();
        }
        
        function buildBallTree() {
            if (points.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆéšæœºç‚¹ï¼');
                return;
            }
            
            buildSteps = ballTree.build([...points]);
            currentStep = 0;
            animateBuild();
        }
        
        function animateBuild() {
            if (currentStep >= buildSteps.length) {
                updateStepDescription("Ball Tree æ„å»ºå®Œæˆï¼ç‚¹å‡»\"å¼€å§‹æœç´¢\"è¿›è¡Œæœ€è¿‘é‚»æœç´¢");
                updateTreeStructure();
                return;
            }
            
            const step = buildSteps[currentStep];
            drawVisualization(step);
            
            // åˆ›å»ºå½“å‰æ­¥éª¤çš„éƒ¨åˆ†æ ‘ç»“æ„å¹¶æ˜¾ç¤º
            const partialTree = buildPartialBallTree(currentStep);
            createTreeVisualization(partialTree);
            updateBuildInfo();
            
            if (step.type === 'create_ball') {
                updateStepDescription(`åˆ›å»ºçƒå½¢åŒºåŸŸ ${currentStep + 1}/${buildSteps.length}: 
                    ä¸­å¿ƒ (${step.center.x.toFixed(1)}, ${step.center.y.toFixed(1)}), åŠå¾„ ${step.radius.toFixed(1)}
                    ${step.isLeaf ? '(å¶èŠ‚ç‚¹)' : ''}`);
            } else if (step.type === 'split') {
                updateStepDescription(`åˆ†å‰²æ­¥éª¤: åœ¨${step.splitDimension === 0 ? 'X' : 'Y'}è½´åˆ†å‰²
                    å·¦å­æ ‘: ${step.leftPoints.length} ç‚¹, å³å­æ ‘: ${step.rightPoints.length} ç‚¹`);
            }
            
            currentStep++;
            setTimeout(() => animateBuild(), 2000);
        }
        
        let searchSteps = [];
        let currentSearchStep = 0;
        let isSearching = false;
        let searchPaused = false;
        let searchTimeoutId = null;
        let searchSpeed = 1500; // é»˜è®¤1.5ç§’é—´éš”

        function startSearch() {
            if (!ballTree.root) {
                alert('è¯·å…ˆæ„å»º Ball Treeï¼');
                return;
            }
            
            if (isSearching) {
                return; // é˜²æ­¢é‡å¤æœç´¢
            }
            
            // Generate random query point
            queryPoint = new Point(
                Math.random() * (canvas.width - 40) + 20,
                Math.random() * (canvas.height - 40) + 20
            );
            
            // è·å–æœç´¢æ­¥éª¤
            searchResult = ballTree.findNearest(queryPoint);
            searchSteps = searchResult.steps;
            currentSearchStep = 0;
            isSearching = true;

            updateStepDescription(`å¼€å§‹æœç´¢æœ€è¿‘é‚»ï¼æŸ¥è¯¢ç‚¹: (${queryPoint.x.toFixed(1)}, ${queryPoint.y.toFixed(1)})`);
            
            // æ˜¾ç¤ºæš‚åœæŒ‰é’®
            document.getElementById('pauseBtn').style.display = 'inline-block';
            
            // å¼€å§‹åŠ¨ç”»æœç´¢è¿‡ç¨‹
            animateSearch();
        }

        function animateSearch() {
            if (searchPaused) return;
            
            if (currentSearchStep >= searchSteps.length) {
                // æœç´¢å®Œæˆ
                isSearching = false;
                searchPaused = false;
                document.getElementById('pauseBtn').style.display = 'none';
                drawSearchResult();
                updateStepDescription(`æœç´¢å®Œæˆï¼æŸ¥è¯¢ç‚¹: (${queryPoint.x.toFixed(1)}, ${queryPoint.y.toFixed(1)})
                    æœ€è¿‘é‚»: (${searchResult.nearest.x.toFixed(1)}, ${searchResult.nearest.y.toFixed(1)})
                    è·ç¦»: ${searchResult.distance.toFixed(2)}`);
                return;
            }

            const step = searchSteps[currentSearchStep];
            drawSearchStep(step);
            
            // æ›´æ–°æ­¥éª¤æè¿°
            updateSearchStepDescription(step);
            
            currentSearchStep++;
            searchTimeoutId = setTimeout(() => animateSearch(), searchSpeed);
        }

        function toggleSearchPause() {
            const pauseBtn = document.getElementById('pauseBtn');
            if (searchPaused) {
                searchPaused = false;
                pauseBtn.textContent = 'æš‚åœ';
                animateSearch();
            } else {
                searchPaused = true;
                pauseBtn.textContent = 'ç»§ç»­';
                if (searchTimeoutId) {
                    clearTimeout(searchTimeoutId);
                }
            }
        }

        function updateSearchSpeed() {
            const slider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            searchSpeed = parseFloat(slider.value) * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
            speedValue.textContent = slider.value + 's';
        }

        function setSpeed(speed) {
            const slider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            slider.value = speed;
            searchSpeed = speed * 1000;
            speedValue.textContent = speed + 's';
        }

        function drawSearchStep(step) {
            // ç»˜åˆ¶åŸºç¡€å†…å®¹
            drawPoints();
            
            // ç»˜åˆ¶æ‰€æœ‰çƒå½¢åŒºåŸŸ
            const drawAllBalls = (node, alpha = 0.3) => {
                if (!node) return;
                ctx.strokeStyle = '#805ad5';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.globalAlpha = alpha;
                
                ctx.beginPath();
                ctx.arc(node.center.x, node.center.y, node.radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
                
                drawAllBalls(node.left, alpha);
                drawAllBalls(node.right, alpha);
            };
            
            drawAllBalls(ballTree.root);

            // ç»˜åˆ¶æŸ¥è¯¢ç‚¹
            ctx.fillStyle = '#e53e3e';
            ctx.beginPath();
            ctx.arc(queryPoint.x, queryPoint.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            // æ ¹æ®æ­¥éª¤ç±»å‹ç»˜åˆ¶ä¸åŒçš„å¯è§†åŒ–æ•ˆæœ
            if (step.type === 'visit_ball') {
                // é«˜äº®å½“å‰è®¿é—®çš„çƒ
                ctx.strokeStyle = step.canPrune ? '#ff6b35' : '#ffd700';
                ctx.lineWidth = 4;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(step.node.center.x, step.node.center.y, step.node.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.globalAlpha = 1;

                // ç»˜åˆ¶åˆ°çƒå¿ƒçš„è·ç¦»çº¿
                ctx.strokeStyle = '#718096';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(queryPoint.x, queryPoint.y);
                ctx.lineTo(step.node.center.x, step.node.center.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // é«˜äº®çƒå¿ƒ
                ctx.fillStyle = step.canPrune ? '#ff6b35' : '#ffd700';
                ctx.beginPath();
                ctx.arc(step.node.center.x, step.node.center.y, 6, 0, 2 * Math.PI);
                ctx.fill();

            } else if (step.type === 'prune') {
                // æ˜¾ç¤ºè¢«å‰ªæçš„çƒ
                ctx.strokeStyle = '#e53e3e';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(step.node.center.x, step.node.center.y, step.node.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);

            } else if (step.type === 'check_point') {
                // é«˜äº®æ£€æŸ¥çš„æ•°æ®ç‚¹
                ctx.fillStyle = step.isBest ? '#38a169' : '#ffd700';
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(step.point.x, step.point.y, step.isBest ? 12 : 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // ç»˜åˆ¶è·ç¦»çº¿
                ctx.strokeStyle = step.isBest ? '#38a169' : '#718096';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(queryPoint.x, queryPoint.y);
                ctx.lineTo(step.point.x, step.point.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // é«˜äº®æ ‘ç»“æ„ä¸­å¯¹åº”çš„èŠ‚ç‚¹
            highlightTreeNode(step);
        }

        function updateSearchStepDescription(step) {
            let description = `æœç´¢æ­¥éª¤ ${currentSearchStep + 1}/${searchSteps.length}: `;
            
            if (step.type === 'visit_ball') {
                description += `è®¿é—®çƒå½¢åŒºåŸŸ ä¸­å¿ƒ(${step.node.center.x.toFixed(1)}, ${step.node.center.y.toFixed(1)}) 
                    åŠå¾„${step.node.radius.toFixed(1)} è·ç¦»${step.centerDistance.toFixed(2)}`;
                if (step.canPrune) {
                    description += ` - å¯ä»¥å‰ªæ`;
                }
            } else if (step.type === 'prune') {
                description += `å‰ªæçƒå½¢åŒºåŸŸ - ${step.reason}`;
            } else if (step.type === 'check_point') {
                description += `æ£€æŸ¥æ•°æ®ç‚¹ (${step.point.x.toFixed(1)}, ${step.point.y.toFixed(1)})
                    è·ç¦»: ${step.distance.toFixed(2)}`;
                if (step.isBest) {
                    description += ` - æ–°çš„æœ€è¿‘é‚»ï¼`;
                }
            }
            
            updateStepDescription(description);
        }

        function highlightTreeNode(step) {
            // åœ¨æ ‘å½¢å›¾ä¸­é«˜äº®å¯¹åº”çš„èŠ‚ç‚¹
            d3.selectAll('.tree-node').classed('searching', false);
            
            // æ‰¾åˆ°å¯¹åº”çš„èŠ‚ç‚¹å¹¶é«˜äº®
            if (step.node) {
                d3.selectAll('.tree-node')
                    .filter(d => {
                        return Math.abs(d.data.centerX - step.node.center.x) < 0.1 && 
                               Math.abs(d.data.centerY - step.node.center.y) < 0.1 &&
                               Math.abs(d.data.radius - step.node.radius) < 0.1;
                    })
                    .classed('searching', true);
            }
        }
        
        function reset() {
            currentStep = 0;
            buildSteps = [];
            queryPoint = null;
            searchResult = null;
            searchSteps = [];
            currentSearchStep = 0;
            isSearching = false;
            ballTree = new BallTree();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateStepDescription("ç‚¹å‡»\"ç”Ÿæˆéšæœºç‚¹\"å¼€å§‹æ¼”ç¤º");
            d3.select("#treeSvg").selectAll("*").remove();
            d3.selectAll(".tree-tooltip").remove();
            d3.selectAll('.tree-node').classed('searching', false);
            document.getElementById('pauseBtn').style.display = 'none';
            if (searchTimeoutId) {
                clearTimeout(searchTimeoutId);
            }
            updateBuildInfo();
        }
        
        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            points.forEach(point => {
                ctx.fillStyle = '#3182ce';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        function drawVisualization(step) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw all points
            points.forEach(point => {
                ctx.fillStyle = '#3182ce';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw balls for completed steps
            for (let i = 0; i <= currentStep && i < buildSteps.length; i++) {
                const s = buildSteps[i];
                if (s.type === 'create_ball') {
                    drawBall(s.center, s.radius, i === currentStep, s.isLeaf);
                }
            }
        }
        
        function drawBall(center, radius, highlight = false, isLeaf = false) {
            // Draw ball boundary
            ctx.strokeStyle = highlight ? '#e53e3e' : '#805ad5';
            ctx.lineWidth = highlight ? 3 : 1;
            ctx.setLineDash(isLeaf ? [] : [5, 5]);
            ctx.globalAlpha = 0.6;
            
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Fill ball area
            ctx.fillStyle = highlight ? 'rgba(229, 62, 62, 0.1)' : 'rgba(128, 90, 213, 0.1)';
            ctx.fill();
            
            ctx.globalAlpha = 1;
            ctx.setLineDash([]);
            
            // Draw center point
            ctx.fillStyle = highlight ? '#e53e3e' : '#805ad5';
            ctx.beginPath();
            ctx.arc(center.x, center.y, highlight ? 6 : 4, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawSearchResult() {
            drawPoints();
            
            // Draw all balls
            const drawAllBalls = (node) => {
                if (!node) return;
                drawBall(node.center, node.radius, false, node.isLeaf);
                drawAllBalls(node.left);
                drawAllBalls(node.right);
            };
            
            drawAllBalls(ballTree.root);
            
            // Draw query point
            ctx.fillStyle = '#e53e3e';
            ctx.beginPath();
            ctx.arc(queryPoint.x, queryPoint.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw nearest neighbor
            ctx.fillStyle = '#38a169';
            ctx.beginPath();
            ctx.arc(searchResult.nearest.x, searchResult.nearest.y, 10, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw connection line
            ctx.strokeStyle = '#38a169';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(queryPoint.x, queryPoint.y);
            ctx.lineTo(searchResult.nearest.x, searchResult.nearest.y);
            ctx.stroke();
        }
        
        function updateStepDescription(text) {
            document.getElementById('stepDescription').textContent = text;
        }
        
        function updateTreeStructure() {
            createTreeVisualization(ballTree.root);
            updateBuildInfo();
        }

        function buildPartialBallTree(stepIndex) {
            if (stepIndex < 0 || stepIndex >= buildSteps.length) return null;
            
            // æ”¶é›†åˆ°å½“å‰æ­¥éª¤ä¸ºæ­¢çš„æ‰€æœ‰çƒèŠ‚ç‚¹
            const ballNodes = [];
            const nodeMap = new Map();
            
            for (let i = 0; i <= stepIndex; i++) {
                const step = buildSteps[i];
                if (step.type === 'create_ball') {
                    const nodeKey = `${step.center.x.toFixed(3)},${step.center.y.toFixed(3)},${step.radius.toFixed(3)}`;
                    
                    if (!nodeMap.has(nodeKey)) {
                        const node = new BallNode(step.center, step.radius, step.isLeaf ? step.points : []);
                        node.isLeaf = step.isLeaf;
                        node.depth = step.depth;
                        ballNodes.push(node);
                        nodeMap.set(nodeKey, node);
                    }
                }
            }
            
            if (ballNodes.length === 0) return null;
            
            // æŒ‰æ·±åº¦æ’åºï¼Œæ„å»ºçˆ¶å­å…³ç³»
            ballNodes.sort((a, b) => a.depth - b.depth);
            
            const root = ballNodes[0];
            
            // ç®€åŒ–çš„çˆ¶å­å…³ç³»æ„å»º
            for (let i = 1; i < ballNodes.length; i++) {
                const node = ballNodes[i];
                const parent = findParentNode(node, ballNodes.slice(0, i));
                if (parent) {
                    if (!parent.left) {
                        parent.left = node;
                    } else if (!parent.right) {
                        parent.right = node;
                    }
                }
            }
            
            return root;
        }
        
        function findParentNode(childNode, potentialParents) {
            // æ‰¾åˆ°æ·±åº¦æ¯”å½“å‰èŠ‚ç‚¹å°1çš„èŠ‚ç‚¹ä½œä¸ºçˆ¶èŠ‚ç‚¹
            for (let i = potentialParents.length - 1; i >= 0; i--) {
                const parent = potentialParents[i];
                if (parent.depth === childNode.depth - 1) {
                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ç©ºçš„å­èŠ‚ç‚¹ä½ç½®
                    if (!parent.left || !parent.right) {
                        return parent;
                    }
                }
            }
            return null;
        }
        
        function createTreeVisualization(root) {
            if (!root) {
                d3.select("#treeSvg").selectAll("*").remove();
                return;
            }

            const svg = d3.select("#treeSvg");
            const container = document.getElementById('treeVisualization');
            const width = container.clientWidth - 20;
            const height = container.clientHeight - 20;
            
            svg.selectAll("*").remove();
            
            // æ¸…ç†ç°æœ‰çš„tooltip
            d3.selectAll(".tree-tooltip").remove();
            
            // åˆ›å»ºæ ‘å¸ƒå±€
            const treeLayout = d3.tree().size([width - 80, height - 80]);
            
            // è½¬æ¢æ•°æ®æ ¼å¼
            const hierarchyData = convertToHierarchy(root);
            const treeData = treeLayout(d3.hierarchy(hierarchyData));
            
            const g = svg.append("g").attr("transform", "translate(40,40)");
            
            // åˆ›å»ºtooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "tree-tooltip");
            
            // ç»˜åˆ¶è¿æ¥çº¿
            g.selectAll(".tree-link")
                .data(treeData.links())
                .enter().append("path")
                .attr("class", "tree-link")
                .attr("d", d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y));
            
            // ç»˜åˆ¶èŠ‚ç‚¹
            const nodes = g.selectAll(".tree-node")
                .data(treeData.descendants())
                .enter().append("g")
                .attr("class", d => {
                    const baseClass = `tree-node ${d.data.isLeaf ? 'leaf-node' : 'internal-node'}`;
                    const isBuilding = currentStep > 0 && currentStep <= buildSteps.length;
                    const isLatestNode = isBuilding && d.depth === Math.max(...treeData.descendants().map(n => n.depth));
                    return isLatestNode ? `${baseClass} building` : baseClass;
                })
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            // æ·»åŠ åœ†åœˆ
            nodes.append("circle")
                .attr("r", d => d.data.isLeaf ? 12 : 18);
            
            // æ·»åŠ èŠ‚ç‚¹ç±»å‹æ ‡ç­¾ï¼ˆåœ¨åœ†åœˆå†…ï¼‰
            nodes.append("text")
                .attr("dy", "-0.2em")
                .text(d => d.data.isLeaf ? d.data.pointCount : 'âš½')
                .style("font-weight", "bold")
                .style("font-size", d => d.data.isLeaf ? "10px" : "14px")
                .style("fill", d => d.data.isLeaf ? "#4a5568" : "white")
                .style("text-anchor", "middle");

            // æ·»åŠ çƒå¿ƒåæ ‡æ ‡ç­¾ï¼ˆåœ¨åœ†åœˆä¸‹æ–¹ï¼‰
            nodes.append("text")
                .attr("dy", "30px")
                .text(d => `(${d.data.centerX.toFixed(1)}, ${d.data.centerY.toFixed(1)})`)
                .style("font-size", "9px")
                .style("fill", "#4a5568")
                .style("text-anchor", "middle")
                .style("font-weight", "500");

            // æ·»åŠ åŠå¾„æ ‡ç­¾ï¼ˆåœ¨åæ ‡ä¸‹æ–¹ï¼‰
            nodes.append("text")
                .attr("dy", "42px")
                .text(d => `r=${d.data.radius.toFixed(1)}`)
                .style("font-size", "8px")
                .style("fill", "#718096")
                .style("text-anchor", "middle");

            // æ·»åŠ èŠ‚ç‚¹ç±»å‹æ ‡ç­¾ï¼ˆåœ¨åŠå¾„ä¸‹æ–¹ï¼‰
            nodes.append("text")
                .attr("dy", "54px")
                .text(d => d.data.isLeaf ? `å¶èŠ‚ç‚¹` : `å†…éƒ¨èŠ‚ç‚¹`)
                .style("font-size", "8px")
                .style("fill", "#718096")
                .style("text-anchor", "middle")
                .style("font-style", "italic");
            
            // æ·»åŠ äº¤äº’
            nodes
                .on("mouseover", function(event, d) {
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`
                        <strong>${d.data.isLeaf ? 'å¶èŠ‚ç‚¹' : 'å†…éƒ¨èŠ‚ç‚¹'}</strong><br>
                        ä¸­å¿ƒ: (${d.data.centerX.toFixed(1)}, ${d.data.centerY.toFixed(1)})<br>
                        åŠå¾„: ${d.data.radius.toFixed(1)}<br>
                        ${d.data.isLeaf ? `æ•°æ®ç‚¹: ${d.data.pointCount}<br>` : ''}
                        æ·±åº¦: ${d.depth}
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.transition().duration(200).style("opacity", 0);
                });
        }
        
        function convertToHierarchy(node) {
            if (!node) return null;
            
            const result = {
                centerX: node.center.x,
                centerY: node.center.y,
                radius: node.radius,
                isLeaf: node.isLeaf,
                pointCount: node.isLeaf ? node.points.length : 0,
                children: []
            };
            
            if (node.left) {
                result.children.push(convertToHierarchy(node.left));
            }
            if (node.right) {
                result.children.push(convertToHierarchy(node.right));
            }
            
            if (result.children.length === 0) {
                delete result.children;
            }
            
            return result;
        }
        
        function updateBuildInfo() {
            const buildInfoElement = document.getElementById('buildInfo');
            if (points.length === 0) {
                buildInfoElement.innerHTML = 'ç‚¹å‡»"ç”Ÿæˆéšæœºç‚¹"å¼€å§‹';
                return;
            }
            
            const totalSteps = buildSteps.length;
            const isBuilding = currentStep > 0 && currentStep <= totalSteps;
            
            if (isBuilding) {
                // æ„å»ºè¿‡ç¨‹ä¸­æ˜¾ç¤ºè¿›åº¦ä¿¡æ¯
                const ballSteps = buildSteps.slice(0, currentStep + 1).filter(s => s.type === 'create_ball');
                buildInfoElement.innerHTML = `
                    æ•°æ®ç‚¹æ•°: ${points.length}<br>
                    æ„å»ºè¿›åº¦: ${currentStep}/${totalSteps} (${Math.round(currentStep/totalSteps*100)}%)<br>
                    å·²åˆ›å»ºçƒ: ${ballSteps.length}<br>
                    å½“å‰æ˜¾ç¤º: éƒ¨åˆ†æ ‘ç»“æ„<br>
                    çŠ¶æ€: æ„å»ºä¸­...
                `;
            } else {
                // æ„å»ºå®Œæˆåæ˜¾ç¤ºå®Œæ•´ä¿¡æ¯
                const treeDepth = ballTree.getDepth();
                const nodeCount = ballTree.nodeCount;
                const leafNodes = countLeafNodes(ballTree.root);
                
                buildInfoElement.innerHTML = `
                    æ•°æ®ç‚¹æ•°: ${points.length}<br>
                    æ„å»ºæ­¥éª¤: ${totalSteps}<br>
                    æ ‘æ·±åº¦: ${treeDepth}<br>
                    æ€»èŠ‚ç‚¹æ•°: ${nodeCount}<br>
                    å¶èŠ‚ç‚¹æ•°: ${leafNodes}<br>
                    çŠ¶æ€: æ„å»ºå®Œæˆ
                `;
            }
        }
        
        function countLeafNodes(node) {
            if (!node) return 0;
            if (node.isLeaf) return 1;
            return countLeafNodes(node.left) + countLeafNodes(node.right);
        }
        

        
        // Initialize
        generateRandomPoints();
    </script>
</body>
</html>