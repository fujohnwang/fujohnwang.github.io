<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vamana ç®—æ³•åŠ¨æ€æ¼”ç¤º</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: #333;
        }

        .container {
            max-width: 95vw;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            min-height: 90vh;
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .visualization {
            display: flex;
            gap: 40px;
            margin-top: 30px;
            height: calc(100vh - 300px);
            min-height: 600px;
        }

        .canvas-container {
            flex: 1;
            text-align: center;
            display: flex;
            flex-direction: column;
        }

        canvas {
            border: 3px solid #e2e8f0;
            border-radius: 10px;
            background: #f8fafc;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            width: 100%;
            height: 100%;
        }

        .info-panel {
            flex: 1;
            min-width: 350px;
            background: #f8fafc;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .step-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .step-title {
            font-weight: bold;
            color: #4a5568;
            margin-bottom: 8px;
        }

        .step-description {
            color: #718096;
            line-height: 1.5;
        }

        .graph-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #f093fb;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 15px;
        }

        .author-info {
            text-align: center;
            padding: 20px;
            color: #718096;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.8);
            margin-top: 20px;
        }

        .author-info a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .author-info a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .speed-control-container {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }

        .speed-control {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-label {
            color: #4a5568;
            font-weight: 500;
            white-space: nowrap;
        }

        .speed-btn {
            margin: 0 5px;
            padding: 5px 10px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .speed-btn:hover {
            background: #667eea !important;
            color: white !important;
            transform: translateY(-1px);
        }

        .speed-slider {
            width: 200px;
            margin: 0 10px;
        }

        .speed-value {
            color: #667eea;
            font-weight: bold;
            margin-left: 10px;
            white-space: nowrap;
        }

        .algorithm-intro {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 40px 20px;
            margin-top: 40px;
        }

        .intro-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .algorithm-intro h2 {
            text-align: center;
            color: #2d3748;
            font-size: 2.2em;
            margin-bottom: 30px;
            font-weight: 700;
        }

        .intro-section {
            background: white;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border-left: 4px solid #667eea;
        }

        .intro-section h3 {
            color: #4a5568;
            font-size: 1.3em;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .intro-section p {
            color: #718096;
            line-height: 1.7;
            margin-bottom: 15px;
        }

        .intro-section ul {
            color: #718096;
            line-height: 1.7;
            padding-left: 20px;
        }

        .intro-section li {
            margin-bottom: 8px;
        }

        .intro-section li strong {
            color: #4a5568;
        }

        .advantages {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .advantage-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .advantage-icon {
            font-size: 1.5em;
            flex-shrink: 0;
        }

        .advantage-item strong {
            color: #4a5568;
            display: block;
            margin-bottom: 5px;
        }

        .advantage-item p {
            color: #718096;
            font-size: 0.9em;
            margin: 0;
        }

        .applications {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .app-tag {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .comparison-item {
            background: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .comparison-item h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .comparison-item ul {
            margin: 0;
            padding-left: 20px;
        }

        .complexity {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .complexity-item {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e2e8f0;
            color: #4a5568;
            font-weight: 500;
        }

        .speed-control input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            outline: none;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .speed-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #4facfe;
        }

        .stats-title {
            font-weight: bold;
            color: #4a5568;
            margin-bottom: 8px;
        }

        .stats-content {
            color: #718096;
            font-size: 14px;
        }

        .parameter-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .param-control {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .param-label {
            color: #4a5568;
            font-weight: 500;
            font-size: 14px;
        }

        .param-value {
            color: #667eea;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ”„ Vamana ç®—æ³•åŠ¨æ€æ¼”ç¤º</h1>

        <div class="controls">
            <button class="btn-primary" onclick="generateRandomPoints()">ç”Ÿæˆéšæœºç‚¹</button>
            <button class="btn-secondary" onclick="buildVamana()">æ„å»º Vamana å›¾</button>
            <button class="btn-success" onclick="startSearch()">å¼€å§‹æœç´¢</button>
            <button class="btn-secondary" onclick="toggleSearchPause()" id="pauseBtn" style="display: none;">æš‚åœ</button>
            <button class="btn-primary" onclick="reset()">é‡ç½®</button>
        </div>

        <div class="parameter-controls">
            <div class="param-control">
                <span class="param-label">æœ€å¤§åº¦æ•° R:</span>
                <span class="param-value" id="maxDegree">6</span>
            </div>
            <div class="param-control">
                <span class="param-label">å€™é€‰é›†å¤§å° L:</span>
                <span class="param-value" id="candidateSize">10</span>
            </div>
            <div class="param-control">
                <span class="param-label">å‰ªæå‚æ•° Î±:</span>
                <span class="param-value" id="pruningAlpha">1.2</span>
            </div>
        </div>

        <div class="speed-control-container">
            <div class="speed-control">
                <label for="speedSlider" class="speed-label">æ„å»ºé€Ÿåº¦:</label>
                <button onclick="setSpeed(0.5)" class="speed-btn">å¿«é€Ÿ</button>
                <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1.5" class="speed-slider"
                    onchange="updateBuildSpeed()">
                <button onclick="setSpeed(3)" class="speed-btn">æ…¢é€Ÿ</button>
                <span id="speedValue" class="speed-value">1.5s</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #3182ce;"></div>
                <span>æ•°æ®ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b35;"></div>
                <span>æœç´¢èµ·ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffd700;"></div>
                <span>å½“å‰èŠ‚ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f093fb;"></div>
                <span>å€™é€‰ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #38a169;"></div>
                <span>æœ€è¿‘é‚»</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #667eea;"></div>
                <span>å›¾è¾¹</span>
            </div>
        </div>

        <div class="visualization">
            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>

            <div class="info-panel">
                <div class="step-info">
                    <div class="step-title">å½“å‰æ­¥éª¤</div>
                    <div class="step-description" id="stepDescription">
                        ç‚¹å‡»"ç”Ÿæˆéšæœºç‚¹"å¼€å§‹æ¼”ç¤º
                    </div>
                </div>

                <div class="graph-info">
                    <div style="font-weight: bold; margin-bottom: 10px; color: #4a5568;">æ„å»ºä¿¡æ¯:</div>
                    <div id="buildInfo" style="margin-bottom: 15px; color: #718096; font-size: 14px;">
                        ç‚¹å‡»"ç”Ÿæˆéšæœºç‚¹"å¼€å§‹
                    </div>
                </div>

                <div class="stats">
                    <div class="stats-title">ç®—æ³•ç»Ÿè®¡</div>
                    <div class="stats-content" id="algorithmStats">
                        ç­‰å¾…å¼€å§‹æ„å»º...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="algorithm-intro">
        <div class="intro-container">
            <h2>ğŸ”„ Vamana ç®—æ³•ä»‹ç»</h2>

            <div class="intro-section">
                <h3>ğŸ“– ç®—æ³•æ¦‚è¿°</h3>
                <p>Vamanaæ˜¯DiskANNä¸­çš„æ ¸å¿ƒå›¾æ„å»ºç®—æ³•ï¼Œé€šè¿‡è¿­ä»£ä¼˜åŒ–è¿‡ç¨‹æ„å»ºé«˜è´¨é‡çš„è¿‘ä¼¼æœ€è¿‘é‚»æœç´¢å›¾ã€‚å®ƒä½¿ç”¨è´ªå¿ƒæœç´¢å’Œæ™ºèƒ½å‰ªæç­–ç•¥ï¼Œåœ¨ä¿è¯æœç´¢è´¨é‡çš„åŒæ—¶æ§åˆ¶å›¾çš„å¤æ‚åº¦ã€‚</p>
            </div>

            <div class="intro-section">
                <h3>ğŸ”§ æ ¸å¿ƒæ€æƒ³</h3>
                <ul>
                    <li><strong>éšæœºå›¾åˆå§‹åŒ–</strong>ï¼šä¸ºæ¯ä¸ªèŠ‚ç‚¹éšæœºåˆ†é…åˆå§‹é‚»å±…è¿æ¥</li>
                    <li><strong>è¿­ä»£ä¼˜åŒ–</strong>ï¼šé€šè¿‡è´ªå¿ƒæœç´¢ä¸ºæ¯ä¸ªèŠ‚ç‚¹å¯»æ‰¾æœ€ä¼˜é‚»å±…é›†åˆ</li>
                    <li><strong>RobustPruneå‰ªæ</strong>ï¼šä½¿ç”¨è§’åº¦å‰ªæå’Œè·ç¦»çº¦æŸä¼˜åŒ–å›¾ç»“æ„</li>
                    <li><strong>åº¦æ•°æ§åˆ¶</strong>ï¼šé™åˆ¶æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§è¿æ¥æ•°ï¼Œå¹³è¡¡è´¨é‡å’Œæ•ˆç‡</li>
                </ul>
            </div>

            <div class="intro-section">
                <h3>ğŸš€ ç®—æ³•ä¼˜åŠ¿</h3>
                <div class="advantages">
                    <div class="advantage-item">
                        <span class="advantage-icon">ğŸ¯</span>
                        <div>
                            <strong>é«˜è´¨é‡å›¾</strong>
                            <p>é€šè¿‡è¿­ä»£ä¼˜åŒ–æ„å»ºé«˜è¿é€šæ€§çš„æœç´¢å›¾</p>
                        </div>
                    </div>
                    <div class="advantage-item">
                        <span class="advantage-icon">âš¡</span>
                        <div>
                            <strong>é«˜æ•ˆæœç´¢</strong>
                            <p>ä¼˜åŒ–çš„å›¾ç»“æ„æ”¯æŒå¿«é€Ÿçš„è´ªå¿ƒæœç´¢</p>
                        </div>
                    </div>
                    <div class="advantage-item">
                        <span class="advantage-icon">ğŸ”§</span>
                        <div>
                            <strong>å‚æ•°å¯è°ƒ</strong>
                            <p>æ”¯æŒå¤šç§å‚æ•°è°ƒèŠ‚ä»¥é€‚åº”ä¸åŒåœºæ™¯</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="intro-section">
                <h3>ğŸ’¡ åº”ç”¨åœºæ™¯</h3>
                <div class="applications">
                    <span class="app-tag">ğŸ” å¤§è§„æ¨¡æ£€ç´¢</span>
                    <span class="app-tag">ğŸ–¼ï¸ å›¾åƒæœç´¢</span>
                    <span class="app-tag">ğŸ“Š å‘é‡æ•°æ®åº“</span>
                    <span class="app-tag">ğŸ¤– æœºå™¨å­¦ä¹ </span>
                    <span class="app-tag">ğŸµ å¤šåª’ä½“æ£€ç´¢</span>
                    <span class="app-tag">ğŸ“ æ–‡æ¡£ç›¸ä¼¼æ€§</span>
                </div>
            </div>

            <div class="intro-section">
                <h3>âš™ï¸ å…³é”®å‚æ•°</h3>
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>ğŸ”¢ æœ€å¤§åº¦æ•° R</h4>
                        <ul>
                            <li>æ§åˆ¶æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§è¿æ¥æ•°</li>
                            <li>å½±å“å›¾çš„ç¨ å¯†åº¦å’Œæœç´¢è´¨é‡</li>
                            <li>å…¸å‹å€¼ï¼š32-128</li>
                        </ul>
                    </div>
                    <div class="comparison-item">
                        <h4>ğŸ“‹ å€™é€‰é›†å¤§å° L</h4>
                        <ul>
                            <li>æœç´¢è¿‡ç¨‹ä¸­ç»´ï¿½ï¿½çš„å€™é€‰æ•°é‡</li>
                            <li>å½±å“æ„å»ºè´¨é‡å’Œæ—¶é—´å¤æ‚åº¦</li>
                            <li>é€šå¸¸è®¾ä¸º R çš„ 1.5-2 å€</li>
                        </ul>
                    </div>
                    <div class="comparison-item">
                        <h4>âœ‚ï¸ å‰ªæå‚æ•° Î±</h4>
                        <ul>
                            <li>æ§åˆ¶å‰ªæçš„æ¿€è¿›ç¨‹åº¦</li>
                            <li>å¹³è¡¡å›¾è´¨é‡å’Œæ„å»ºæ•ˆç‡</li>
                            <li>å…¸å‹å€¼ï¼š1.0-1.5</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="intro-section">
                <h3>ğŸ“ˆ å¤æ‚åº¦åˆ†æ</h3>
                <div class="complexity">
                    <div class="complexity-item">
                        <strong>æ„å»ºæ—¶é—´</strong>: O(nÂ·LÂ·R)
                    </div>
                    <div class="complexity-item">
                        <strong>æœç´¢æ—¶é—´</strong>: O(LÂ·log n)
                    </div>
                    <div class="complexity-item">
                        <strong>ç©ºé—´å¤æ‚åº¦</strong>: O(nÂ·R)
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="author-info">
        by <a href="https://afoo.me" target="_blank">ç¦å¼º</a> & Kiro
    </div>

    <script>
        class Point {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.neighbors = [];
            }

            distance(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }
        }

        class VamanaGraph {
            constructor(maxDegree = 6, candidateSize = 10, alpha = 1.2) {
                this.points = [];
                this.startingPoint = null;
                this.maxDegree = maxDegree;
                this.candidateSize = candidateSize;
                this.alpha = alpha;
                this.buildSteps = [];
            }

            build(points) {
                this.points = [...points];
                this.buildSteps = [];

                if (points.length === 0) return [];

                // ç¬¬ä¸€æ­¥ï¼šåˆå§‹åŒ–éšæœºå›¾
                this.initializeRandomGraph();

                // ç¬¬äºŒæ­¥ï¼šè¿­ä»£ä¼˜åŒ–æ¯ä¸ªèŠ‚ç‚¹çš„é‚»å±…
                for (let i = 0; i < this.points.length; i++) {
                    this.optimizeNodeNeighbors(this.points[i], i);
                }

                // æ„å»ºå®Œæˆ
                this.buildSteps.push({
                    type: 'build_complete',
                    message: 'Vamanaå›¾æ„å»ºå®Œæˆ'
                });

                return this.buildSteps;
            }



            initializeRandomGraph() {
                // ä¸ºæ¯ä¸ªç‚¹åˆå§‹åŒ–éšæœºé‚»å±…ï¼ˆç®€åŒ–ç‰ˆï¼‰
                for (const point of this.points) {
                    const others = this.points.filter(p => p !== point);
                    const shuffled = others.sort(() => Math.random() - 0.5);
                    point.neighbors = shuffled.slice(0, Math.min(this.maxDegree, others.length));
                }

                this.buildSteps.push({
                    type: 'initialize_random',
                    message: 'åˆå§‹åŒ–éšæœºå›¾ç»“æ„'
                });
            }

            optimizeNodeNeighbors(point, pointIndex) {
                this.buildSteps.push({
                    type: 'start_optimize',
                    point: point,
                    index: pointIndex
                });

                // ä½¿ç”¨è´ªå¿ƒæœç´¢æ‰¾åˆ°å€™é€‰é‚»å±…
                const candidates = this.greedySearchCandidates(point);

                this.buildSteps.push({
                    type: 'find_candidates',
                    point: point,
                    candidates: candidates
                });

                // ä½¿ç”¨RobustPruneå‰ªæé€‰æ‹©æœ€ç»ˆé‚»å±…
                const prunedNeighbors = this.robustPrune(point, candidates);

                // æ›´æ–°é‚»å±…
                point.neighbors = prunedNeighbors;

                this.buildSteps.push({
                    type: 'prune_neighbors',
                    point: point,
                    candidates: candidates,
                    finalNeighbors: prunedNeighbors,
                    prunedCount: candidates.length - prunedNeighbors.length
                });

                // åå‘è¿æ¥æ›´æ–°
                this.updateReverseConnections(point, prunedNeighbors);
            }

            greedySearchCandidates(queryPoint) {
                const visited = new Set();
                const candidates = [];

                // åœ¨æ„å»ºé˜¶æ®µï¼Œä»éšæœºç‚¹å¼€å§‹è´ªå¿ƒæœç´¢
                let current = this.points[Math.floor(Math.random() * this.points.length)];
                visited.add(current.id);

                if (current !== queryPoint) {
                    candidates.push({
                        point: current,
                        distance: queryPoint.distance(current)
                    });
                }

                // è´ªå¿ƒæœç´¢æ‰©å±•
                let improved = true;
                while (improved && candidates.length < this.candidateSize) {
                    improved = false;
                    let bestNeighbor = null;
                    let bestDistance = Infinity;

                    // æ£€æŸ¥å½“å‰ç‚¹çš„æ‰€æœ‰é‚»å±…
                    for (const neighbor of current.neighbors) {
                        if (!visited.has(neighbor.id) && neighbor !== queryPoint) {
                            const distance = queryPoint.distance(neighbor);
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                bestNeighbor = neighbor;
                            }
                        }
                    }

                    if (bestNeighbor) {
                        visited.add(bestNeighbor.id);
                        candidates.push({
                            point: bestNeighbor,
                            distance: bestDistance
                        });
                        current = bestNeighbor;
                        improved = true;
                    }
                }

                // å¦‚æœå€™é€‰ä¸å¤Ÿï¼Œæ·»åŠ ä¸€äº›éšæœºç‚¹
                while (candidates.length < this.candidateSize) {
                    const remaining = this.points.filter(p =>
                        !visited.has(p.id) && p !== queryPoint);
                    if (remaining.length === 0) break;

                    const randomPoint = remaining[Math.floor(Math.random() * remaining.length)];
                    visited.add(randomPoint.id);
                    candidates.push({
                        point: randomPoint,
                        distance: queryPoint.distance(randomPoint)
                    });
                }

                // æŒ‰è·ç¦»æ’åº
                candidates.sort((a, b) => a.distance - b.distance);
                return candidates.slice(0, this.candidateSize);
            }

            robustPrune(queryPoint, candidates) {
                if (candidates.length <= this.maxDegree) {
                    return candidates.map(c => c.point);
                }

                const result = [];
                const remaining = [...candidates];

                // æ€»æ˜¯ä¿ç•™æœ€è¿‘çš„ç‚¹
                if (remaining.length > 0) {
                    result.push(remaining.shift().point);
                }

                // ä½¿ç”¨è§’åº¦å‰ªæé€‰æ‹©å…¶ä½™é‚»å±…
                while (result.length < this.maxDegree && remaining.length > 0) {
                    let bestCandidate = null;
                    let bestIndex = -1;
                    let bestScore = -Infinity;

                    for (let i = 0; i < remaining.length; i++) {
                        const candidate = remaining[i];

                        // è®¡ç®—ä¸å·²é€‰æ‹©é‚»å±…çš„è§’åº¦åˆ†æ•£æ€§
                        let minAngle = Math.PI;
                        for (const neighbor of result) {
                            const angle = this.calculateAngle(queryPoint, candidate.point, neighbor);
                            minAngle = Math.min(minAngle, angle);
                        }

                        // ç»“åˆè·ç¦»å’Œè§’åº¦çš„è¯„åˆ†
                        const distanceScore = 1.0 / (1.0 + candidate.distance);
                        const angleScore = minAngle / Math.PI;
                        const score = distanceScore * this.alpha + angleScore;

                        if (score > bestScore) {
                            bestScore = score;
                            bestCandidate = candidate;
                            bestIndex = i;
                        }
                    }

                    if (bestCandidate) {
                        result.push(bestCandidate.point);
                        remaining.splice(bestIndex, 1);
                    } else {
                        break;
                    }
                }

                return result;
            }

            calculateAngle(center, point1, point2) {
                const v1x = point1.x - center.x;
                const v1y = point1.y - center.y;
                const v2x = point2.x - center.x;
                const v2y = point2.y - center.y;

                const dot = v1x * v2x + v1y * v2y;
                const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);

                if (mag1 === 0 || mag2 === 0) return 0;

                const cosAngle = dot / (mag1 * mag2);
                return Math.acos(Math.max(-1, Math.min(1, cosAngle)));
            }

            updateReverseConnections(point, neighbors) {
                for (const neighbor of neighbors) {
                    // å¦‚æœé‚»å±…çš„è¿æ¥æ•°æœªæ»¡ï¼Œè€ƒè™‘æ·»åŠ åå‘è¿æ¥
                    if (neighbor.neighbors.length < this.maxDegree &&
                        !neighbor.neighbors.includes(point)) {

                        // ç®€åŒ–ç‰ˆï¼šç›´æ¥æ·»åŠ åå‘è¿æ¥
                        neighbor.neighbors.push(point);

                        this.buildSteps.push({
                            type: 'add_reverse',
                            from: neighbor,
                            to: point
                        });

                        // å¦‚æœè¶…è¿‡æœ€å¤§åº¦æ•°ï¼Œéœ€è¦å‰ªæ
                        if (neighbor.neighbors.length > this.maxDegree) {
                            neighbor.neighbors = neighbor.neighbors
                                .map(n => ({ point: n, distance: neighbor.distance(n) }))
                                .sort((a, b) => a.distance - b.distance)
                                .slice(0, this.maxDegree)
                                .map(n => n.point);
                        }
                    }
                }
            }

            search(queryPoint, k = 1) {
                if (this.points.length === 0) return null;

                const visited = new Set();
                const candidates = [];
                const searchSteps = [];

                // éšæœºé€‰æ‹©ä¸€ä¸ªèµ·å§‹ç‚¹è¿›è¡Œæœç´¢ï¼ˆæ›´ç¬¦åˆVamanaç®—æ³•ï¼‰
                const randomStartIndex = Math.floor(Math.random() * this.points.length);
                let current = this.points[randomStartIndex];
                visited.add(current.id);

                searchSteps.push({
                    type: 'start_search',
                    point: current,
                    distance: queryPoint.distance(current),
                    isRandomStart: true
                });

                candidates.push({
                    point: current,
                    distance: queryPoint.distance(current)
                });

                // è´ªå¿ƒæœç´¢
                let improved = true;
                while (improved) {
                    improved = false;

                    for (const neighbor of current.neighbors) {
                        if (!visited.has(neighbor.id)) {
                            visited.add(neighbor.id);
                            const distance = queryPoint.distance(neighbor);

                            searchSteps.push({
                                type: 'visit_neighbor',
                                from: current,
                                to: neighbor,
                                distance: distance
                            });

                            candidates.push({
                                point: neighbor,
                                distance: distance
                            });

                            if (distance < queryPoint.distance(current)) {
                                current = neighbor;
                                improved = true;

                                searchSteps.push({
                                    type: 'update_current',
                                    point: current,
                                    distance: distance
                                });
                            }
                        }
                    }
                }

                candidates.sort((a, b) => a.distance - b.distance);
                const result = candidates.slice(0, k);

                return {
                    results: result,
                    steps: searchSteps,
                    visited: Array.from(visited)
                };
            }
        }

        // Visualization
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let points = [];
        let vamanaGraph = new VamanaGraph();
        let buildSteps = [];
        let currentStep = 0;
        let queryPoint = null;
        let searchResult = null;
        let animationId = null;

        function generateRandomPoints() {
            points = [];
            // ç”Ÿæˆèšç±»ç‚¹ä»¥ä¾¿æ›´å¥½åœ°å±•ç¤ºç®—æ³•æ•ˆæœ
            const clusters = 3;
            const pointsPerCluster = 8;
            let pointId = 0;

            for (let i = 0; i < clusters; i++) {
                const centerX = Math.random() * (canvas.width - 200) + 100;
                const centerY = Math.random() * (canvas.height - 200) + 100;

                for (let j = 0; j < pointsPerCluster; j++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = Math.random() * 60 + 20;

                    points.push(new Point(
                        centerX + Math.cos(angle) * radius,
                        centerY + Math.sin(angle) * radius,
                        pointId++
                    ));
                }
            }

            reset();
            drawPoints();
            updateStepDescription("å·²ç”Ÿæˆ " + points.length + " ä¸ªèšç±»ç‚¹ï¼Œç‚¹å‡»\"æ„å»º Vamana å›¾\"ç»§ç»­");
            updateBuildInfo();
        }

        function buildVamana() {
            if (points.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆéšæœºç‚¹ï¼');
                return;
            }

            buildSteps = vamanaGraph.build([...points]);
            currentStep = 0;
            animateBuild();
        }

        let buildSpeed = 1500; // é»˜è®¤1.5ç§’é—´éš”

        function animateBuild() {
            if (currentStep >= buildSteps.length) {
                updateStepDescription("Vamana å›¾æ„å»ºå®Œæˆï¼ç‚¹å‡»\"å¼€å§‹æœç´¢\"è¿›è¡Œæœ€è¿‘é‚»æœç´¢");
                drawCompleteGraph();
                updateAlgorithmStats();
                return;
            }

            const step = buildSteps[currentStep];
            drawBuildStep(step);

            updateBuildStepDescription(step);
            updateBuildInfo();
            currentStep++;
            setTimeout(() => animateBuild(), buildSpeed);
        }

        let searchSteps = [];
        let currentSearchStep = 0;
        let isSearching = false;
        let searchPaused = false;
        let searchTimeoutId = null;
        let searchSpeed = 1500;

        function startSearch() {
            if (points.length === 0) {
                alert('è¯·å…ˆæ„å»º Vamana å›¾ï¼');
                return;
            }

            if (isSearching) {
                return;
            }

            // ç”ŸæˆéšæœºæŸ¥è¯¢ç‚¹
            queryPoint = new Point(
                Math.random() * (canvas.width - 40) + 20,
                Math.random() * (canvas.height - 40) + 20,
                -1
            );

            searchResult = vamanaGraph.search(queryPoint);
            searchSteps = searchResult.steps;
            currentSearchStep = 0;
            isSearching = true;

            updateStepDescription(`å¼€å§‹æœç´¢æœ€è¿‘é‚»ï¼æŸ¥è¯¢ç‚¹: (${queryPoint.x.toFixed(1)}, ${queryPoint.y.toFixed(1)})`);

            document.getElementById('pauseBtn').style.display = 'inline-block';
            animateSearch();
        }

        function animateSearch() {
            if (searchPaused) return;

            if (currentSearchStep >= searchSteps.length) {
                isSearching = false;
                searchPaused = false;
                document.getElementById('pauseBtn').style.display = 'none';
                drawSearchResult();

                const nearest = searchResult.results[0];
                updateStepDescription(`æœç´¢å®Œæˆï¼æŸ¥è¯¢ç‚¹: (${queryPoint.x.toFixed(1)}, ${queryPoint.y.toFixed(1)})
                    æœ€è¿‘é‚»: (${nearest.point.x.toFixed(1)}, ${nearest.point.y.toFixed(1)})
                    è·ç¦»: ${nearest.distance.toFixed(2)}`);

                updateSearchStats();
                return;
            }

            const step = searchSteps[currentSearchStep];
            drawSearchStep(step);
            updateSearchStepDescription(step);

            currentSearchStep++;
            searchTimeoutId = setTimeout(() => animateSearch(), searchSpeed);
        }

        function toggleSearchPause() {
            const pauseBtn = document.getElementById('pauseBtn');
            if (searchPaused) {
                searchPaused = false;
                pauseBtn.textContent = 'æš‚åœ';
                animateSearch();
            } else {
                searchPaused = true;
                pauseBtn.textContent = 'ç»§ç»­';
                if (searchTimeoutId) {
                    clearTimeout(searchTimeoutId);
                }
            }
        }

        function updateBuildSpeed() {
            const slider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            buildSpeed = parseFloat(slider.value) * 1000;
            searchSpeed = buildSpeed; // åŒæ­¥æœç´¢é€Ÿåº¦
            speedValue.textContent = slider.value + 's';
        }

        function setSpeed(speed) {
            const slider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            slider.value = speed;
            buildSpeed = speed * 1000;
            searchSpeed = buildSpeed;
            speedValue.textContent = speed + 's';
        }

        function reset() {
            currentStep = 0;
            buildSteps = [];
            queryPoint = null;
            searchResult = null;
            searchSteps = [];
            currentSearchStep = 0;
            isSearching = false;
            vamanaGraph = new VamanaGraph();

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateStepDescription("ç‚¹å‡»\"ç”Ÿæˆéšæœºç‚¹\"å¼€å§‹æ¼”ç¤º");
            document.getElementById('pauseBtn').style.display = 'none';
            if (searchTimeoutId) {
                clearTimeout(searchTimeoutId);
            }
            updateBuildInfo();
            updateAlgorithmStats();
        }

        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            points.forEach(point => {
                ctx.fillStyle = '#3182ce';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function drawStartingPoint(point) {
            // ç»˜åˆ¶æ˜Ÿå½¢èƒŒæ™¯
            ctx.fillStyle = '#ff6b35';
            ctx.strokeStyle = '#e53e3e';
            ctx.lineWidth = 4;

            // ç»˜åˆ¶æ˜Ÿå½¢
            drawStar(ctx, point.x, point.y, 5, 14, 7);
            ctx.fill();
            ctx.stroke();

            // ç»˜åˆ¶ä¸­å¿ƒåœ†ç‚¹
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
            ctx.fill();

            // æ·»åŠ æ–‡å­—æ ‡è¯†
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('èµ·å§‹', point.x, point.y - 20);
        }

        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);

            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }

            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
        }

        function drawBuildStep(step) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶æ‰€æœ‰ç‚¹
            points.forEach(point => {
                if (step.type === 'start_optimize' && point === step.point) {
                    // é«˜äº®å½“å‰ä¼˜åŒ–çš„èŠ‚ç‚¹
                    ctx.fillStyle = '#ffd700';
                    ctx.strokeStyle = '#f6ad55';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#3182ce';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // ç»˜åˆ¶å·²å»ºç«‹çš„è¿æ¥
            points.forEach(point => {
                point.neighbors.forEach(neighbor => {
                    drawEdge(point, neighbor);
                });
            });

            // æ ¹æ®æ­¥éª¤ç±»å‹ç»˜åˆ¶ç‰¹æ®Šæ•ˆæœ
            if (step.type === 'find_candidates') {
                // é«˜äº®å€™é€‰ç‚¹
                step.candidates.forEach(candidate => {
                    ctx.fillStyle = '#f093fb';
                    ctx.strokeStyle = '#e879f9';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(candidate.point.x, candidate.point.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // ç»˜åˆ¶å€™é€‰è¿æ¥çº¿
                    ctx.strokeStyle = '#f093fb';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(step.point.x, step.point.y);
                    ctx.lineTo(candidate.point.x, candidate.point.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
            } else if (step.type === 'prune_neighbors') {
                // æ˜¾ç¤ºå‰ªæç»“æœ
                step.finalNeighbors.forEach(neighbor => {
                    ctx.fillStyle = '#38a169';
                    ctx.strokeStyle = '#2f855a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(neighbor.x, neighbor.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // ç»˜åˆ¶æœ€ç»ˆè¿æ¥
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(step.point.x, step.point.y);
                    ctx.lineTo(neighbor.x, neighbor.y);
                    ctx.stroke();
                });

                // æ˜¾ç¤ºè¢«å‰ªæçš„å€™é€‰
                const prunedCandidates = step.candidates.filter(c =>
                    !step.finalNeighbors.includes(c.point));
                prunedCandidates.forEach(candidate => {
                    ctx.fillStyle = '#e53e3e';
                    ctx.strokeStyle = '#c53030';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(candidate.point.x, candidate.point.y, 7, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                });
            }
        }

        function drawCompleteGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶æ‰€æœ‰è¾¹
            points.forEach(point => {
                point.neighbors.forEach(neighbor => {
                    drawEdge(point, neighbor);
                });
            });

            // ç»˜åˆ¶æ‰€æœ‰ç‚¹
            points.forEach(point => {
                ctx.fillStyle = '#3182ce';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function drawEdge(from, to, highlight = false) {
            ctx.strokeStyle = highlight ? '#e53e3e' : '#718096';
            ctx.lineWidth = highlight ? 3 : 1;
            ctx.globalAlpha = highlight ? 1 : 0.6;

            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            ctx.globalAlpha = 1;
        }

        function drawSearchStep(step) {
            drawCompleteGraph();

            // ç»˜åˆ¶æŸ¥è¯¢ç‚¹
            ctx.fillStyle = '#e53e3e';
            ctx.beginPath();
            ctx.arc(queryPoint.x, queryPoint.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            // æ ¹æ®æ­¥éª¤ç±»å‹ç»˜åˆ¶æ•ˆæœ
            if (step.type === 'start_search') {
                // é«˜äº®éšæœºé€‰æ‹©çš„æœç´¢èµ·ç‚¹
                ctx.fillStyle = '#ff6b35';
                ctx.strokeStyle = '#e53e3e';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(step.point.x, step.point.y, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // æ·»åŠ æ–‡å­—æ ‡è¯†
                ctx.fillStyle = '#ff6b35';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('èµ·ç‚¹', step.point.x, step.point.y - 18);

            } else if (step.type === 'visit_neighbor') {
                ctx.fillStyle = '#f093fb';
                ctx.strokeStyle = '#e879f9';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(step.to.x, step.to.y, 9, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // ç»˜åˆ¶æœç´¢è·¯å¾„
                ctx.strokeStyle = '#f093fb';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(step.from.x, step.from.y);
                ctx.lineTo(step.to.x, step.to.y);
                ctx.stroke();

            } else if (step.type === 'update_current') {
                ctx.fillStyle = '#38a169';
                ctx.strokeStyle = '#2f855a';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(step.point.x, step.point.y, 10, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
        }

        function drawSearchResult() {
            drawCompleteGraph();

            // ç»˜åˆ¶æŸ¥è¯¢ç‚¹
            ctx.fillStyle = '#e53e3e';
            ctx.beginPath();
            ctx.arc(queryPoint.x, queryPoint.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            // ç»˜åˆ¶æœ€è¿‘é‚»
            const nearest = searchResult.results[0];
            ctx.fillStyle = '#38a169';
            ctx.beginPath();
            ctx.arc(nearest.point.x, nearest.point.y, 10, 0, 2 * Math.PI);
            ctx.fill();

            // ç»˜åˆ¶è¿æ¥çº¿
            ctx.strokeStyle = '#38a169';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(queryPoint.x, queryPoint.y);
            ctx.lineTo(nearest.point.x, nearest.point.y);
            ctx.stroke();
        }

        function updateBuildStepDescription(step) {
            let description = `æ„å»ºæ­¥éª¤ ${currentStep + 1}/${buildSteps.length}: `;

            if (step.type === 'build_complete') {
                description += step.message;
            } else if (step.type === 'initialize_random') {
                description += step.message;
            } else if (step.type === 'start_optimize') {
                description += `ä¼˜åŒ–èŠ‚ç‚¹ ${step.index + 1}/${points.length}
                    (${step.point.x.toFixed(1)}, ${step.point.y.toFixed(1)})`;
            } else if (step.type === 'find_candidates') {
                description += `è´ªå¿ƒæœç´¢æ‰¾åˆ° ${step.candidates.length} ä¸ªå€™é€‰é‚»å±…`;
            } else if (step.type === 'prune_neighbors') {
                description += `RobustPruneå‰ªæï¼šä¿ç•™ ${step.finalNeighbors.length} ä¸ªé‚»å±…ï¼Œ
                    å‰ªé™¤ ${step.prunedCount} ä¸ªå€™é€‰`;
            } else if (step.type === 'add_reverse') {
                description += `æ·»åŠ åå‘è¿æ¥: (${step.from.x.toFixed(1)}, ${step.from.y.toFixed(1)}) â†’ 
                    (${step.to.x.toFixed(1)}, ${step.to.y.toFixed(1)})`;
            }

            updateStepDescription(description);
        }

        function updateSearchStepDescription(step) {
            let description = `æœç´¢æ­¥éª¤ ${currentSearchStep + 1}/${searchSteps.length}: `;

            if (step.type === 'start_search') {
                description += `ä»éšæœºèµ·å§‹ç‚¹å¼€å§‹ (${step.point.x.toFixed(1)}, ${step.point.y.toFixed(1)})
                    è·ç¦»: ${step.distance.toFixed(2)}`;
            } else if (step.type === 'visit_neighbor') {
                description += `è®¿é—®é‚»å±… (${step.to.x.toFixed(1)}, ${step.to.y.toFixed(1)})
                    è·ç¦»: ${step.distance.toFixed(2)}`;
            } else if (step.type === 'update_current') {
                description += `æ›´æ–°å½“å‰æœ€ä½³ç‚¹ (${step.point.x.toFixed(1)}, ${step.point.y.toFixed(1)})
                    è·ç¦»: ${step.distance.toFixed(2)}`;
            }

            updateStepDescription(description);
        }

        function updateStepDescription(text) {
            document.getElementById('stepDescription').textContent = text;
        }

        function updateBuildInfo() {
            const buildInfoElement = document.getElementById('buildInfo');
            if (points.length === 0) {
                buildInfoElement.innerHTML = 'ç‚¹å‡»"ç”Ÿæˆéšæœºç‚¹"å¼€å§‹';
                return;
            }

            const totalSteps = buildSteps.length;
            const isBuilding = currentStep > 0 && currentStep <= totalSteps;

            if (isBuilding) {
                const processedNodes = buildSteps.slice(0, currentStep + 1)
                    .filter(s => s.type === 'start_optimize').length;
                buildInfoElement.innerHTML = `
                    æ•°æ®ç‚¹æ•°: ${points.length}<br>
                    æ„å»ºè¿›åº¦: ${currentStep}/${totalSteps} (${Math.round(currentStep / totalSteps * 100)}%)<br>
                    å·²ä¼˜åŒ–èŠ‚ç‚¹: ${processedNodes}<br>
                    çŠ¶æ€: æ„å»ºä¸­...
                `;
            } else {
                const totalConnections = points.reduce((sum, point) => sum + point.neighbors.length, 0);
                const avgConnections = points.length > 0 ? (totalConnections / points.length).toFixed(1) : 0;

                buildInfoElement.innerHTML = `
                    æ•°æ®ç‚¹æ•°: ${points.length}<br>
                    æ„å»ºæ­¥éª¤: ${totalSteps}<br>
                    æ€»è¿æ¥æ•°: ${totalConnections}<br>
                    å¹³å‡è¿æ¥æ•°: ${avgConnections}<br>
                    æœ€å¤§åº¦æ•°: ${vamanaGraph.maxDegree}<br>
                    çŠ¶æ€: æ„å»ºå®Œæˆ
                `;
            }
        }

        function updateAlgorithmStats() {
            const statsElement = document.getElementById('algorithmStats');
            if (points.length === 0) {
                statsElement.innerHTML = 'ç­‰å¾…å¼€å§‹æ„å»º...';
                return;
            }

            const totalConnections = points.reduce((sum, point) => sum + point.neighbors.length, 0);
            const maxConnections = Math.max(...points.map(p => p.neighbors.length));
            const minConnections = Math.min(...points.map(p => p.neighbors.length));

            if (searchResult) {
                const visitedCount = searchResult.visited.length;
                const searchEfficiency = ((points.length - visitedCount) / points.length * 100).toFixed(1);

                statsElement.innerHTML = `
                    æ€»è¿æ¥æ•°: ${totalConnections}<br>
                    æœ€å¤§/æœ€å°åº¦æ•°: ${maxConnections}/${minConnections}<br>
                    è®¿é—®èŠ‚ç‚¹: ${visitedCount}/${points.length}<br>
                    æœç´¢æ•ˆç‡: ${searchEfficiency}% èŠ‚çœ<br>
                    æœ€ç»ˆè·ç¦»: ${searchResult.results[0].distance.toFixed(2)}
                `;
            } else {
                statsElement.innerHTML = `
                    æ€»è¿æ¥æ•°: ${totalConnections}<br>
                    æœ€å¤§/æœ€å°åº¦æ•°: ${maxConnections}/${minConnections}<br>
                    å›¾å¯†åº¦: ${(totalConnections / (points.length * (points.length - 1)) * 100).toFixed(2)}%<br>
                    æ„å»ºå®Œæˆåº¦: 100%
                `;
            }
        }

        function updateSearchStats() {
            updateAlgorithmStats();
        }

        // Initialize
        generateRandomPoints();
    </script>
</body>

</html>